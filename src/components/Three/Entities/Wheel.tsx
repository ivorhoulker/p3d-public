import { FC, Ref, useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { Mesh } from "three";
import { useFrame } from "@react-three/fiber";
import { KeyStateObject } from "./Player";

useGLTF.preload("/wheel.glb");
export const wheelTypes = [
  "frontLeft",
  "frontRight",
  "backLeft",
  "backRight",
] as const;
export type WheelType = typeof wheelTypes[number];

// Auto-generated by: https://github.com/pmndrs/gltfjsx
const Wheel: FC<{ type: WheelType; keyStates: KeyStateObject }> = ({
  type,
  keyStates,
}) => {
  const { nodes: n, materials } = useGLTF("/wheel.glb");
  const nodes = n as Record<string, Mesh>;

  const positionZ = type.startsWith("front") ? 1.2 : -1.3;
  const positionX = type.includes("Left") ? 1.1 : -1.1;
  const rotationZ = type.includes("Left") ? -Math.PI / 2 : Math.PI / 2;

  const ref = useRef<Mesh>(null);
  useFrame(() => {
    // not sure this is performant
    if (ref.current) {
      const wheelSpeed = 10;
      const wheelTurnSpeed = wheelSpeed / 2;
      let s = 0;
      if (type === "frontLeft" || type === "backLeft") {
        if (keyStates.w && type) s += wheelSpeed;
        if (keyStates.s && type) s -= wheelSpeed;
        if (keyStates.q && type) s += wheelSpeed;
        if (keyStates.e && type) s -= wheelSpeed;
      } else if (type === "frontRight" || type == "backRight") {
        if (keyStates.w && type) s += wheelSpeed;
        if (keyStates.s && type) s -= wheelSpeed;
        if (keyStates.q && type) s -= wheelSpeed;
        if (keyStates.e && type) s += wheelSpeed;
      }
      if (type === "frontLeft" || type === "frontRight") {
        if (keyStates.a && keyStates.s) s -= wheelTurnSpeed;
        else if (keyStates.a) s += wheelTurnSpeed;
        if (keyStates.d && keyStates.s) s += wheelTurnSpeed;
        else if (keyStates.d) s -= wheelTurnSpeed;
      } else if (type === "backLeft" || type === "backRight") {
        if (keyStates.a && keyStates.s) s += wheelTurnSpeed;
        else if (keyStates.a) s -= wheelTurnSpeed;
        if (keyStates.d && keyStates.s) s -= wheelTurnSpeed;
        else if (keyStates.d) s += wheelTurnSpeed;
      }

      ref.current.rotation.set(ref.current.rotation.x + s, Math.PI, rotationZ);
    }
  });
  return (
    <mesh
      ref={ref as Ref<Mesh>}
      position={[positionX, 0, positionZ]}
      rotation={[Math.PI / 2, Math.PI, rotationZ]}
      scale={2}
    >
      <mesh material={materials.Rubber} geometry={nodes.wheel_1?.geometry} />
      <mesh material={materials.Steel} geometry={nodes.wheel_2?.geometry} />
      <mesh material={materials.Chrom} geometry={nodes.wheel_3?.geometry} />
    </mesh>
  );
};

export default Wheel;
